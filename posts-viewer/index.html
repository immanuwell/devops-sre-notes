<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>React Posts with Hidden Copy Feature</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Simple styling -->
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 1.5rem;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0b1120;
      color: #e5e7eb;
    }
    h1 {
      margin-bottom: 1rem;
      font-size: 1.6rem;
      color: #f97316;
    }
    .app {
      max-width: 900px;
      margin: 0 auto;
    }
    .hint {
      font-size: 0.85rem;
      color: #9ca3af;
      margin-bottom: 1rem;
    }
    .posts-container {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }
    .post-card {
      background: #020617;
      border: 1px solid #1f2937;
      border-radius: 0.75rem;
      padding: 1rem 1.25rem;
      box-shadow: 0 10px 25px rgba(15, 23, 42, 0.9);
    }
    .post-title {
      font-size: 1rem;
      font-weight: 600;
      color: #fbbf24;
      margin-bottom: 0.75rem;
    }
    .post-content img {
      max-width: 100%;
      height: auto;
      margin: 0.5rem 0;
      border-radius: 0.5rem;
    }
    .post-footer {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      margin-top: 0.75rem;
      font-size: 0.85rem;
      color: #9ca3af;
    }
    .copy-btn {
      padding: 0.25rem 0.75rem;
      border-radius: 999px;
      border: 1px solid #22c55e;
      background: #16a34a;
      color: #022c22;
      font-size: 0.85rem;
      cursor: pointer;
      font-weight: 600;
    }
    .copy-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
    .secret-panel {
      margin-bottom: 1rem;
      padding: 0.75rem 1rem;
      border-radius: 0.75rem;
      background: #020617;
      border: 1px dashed #4b5563;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
      font-size: 0.85rem;
    }
    .secret-panel input {
      background: #020617;
      border-radius: 999px;
      border: 1px solid #4b5563;
      padding: 0.35rem 0.75rem;
      color: #e5e7eb;
      min-width: 180px;
    }
    .secret-panel button {
      padding: 0.3rem 0.7rem;
      border-radius: 999px;
      border: 1px solid #38bdf8;
      background: #0ea5e9;
      color: #02131b;
      font-size: 0.8rem;
      cursor: pointer;
      font-weight: 600;
    }
    .secret-status {
      font-size: 0.8rem;
      color: #9ca3af;
    }
    .error {
      color: #fca5a5;
    }
    .loading, .error-global {
      margin-top: 1rem;
      font-size: 0.9rem;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <!-- React + ReactDOM + Babel via CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

  <!-- Add this: pure JS SHA-256 -->
  <script src="https://cdn.jsdelivr.net/npm/js-sha256@0.11.0/build/sha256.min.js"></script>

  <!-- Babel last -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>


  <script type="text/babel">
    const { useState, useEffect } = React;

    // 1) List your post HTML files here
    //    They should live in ./posts/ directory next to index.html
    const POST_FILES = [
      "post-1.html",
      // "post2.html",
      // add more: "post3.html", ...
    ];

    // 2) SHA-256 hash of the correct passphrase (hex string, 64 chars).
    //    Example below is SHA-256 of the empty string "".
    //    Replace with your own value.
    const SECRET_HASH =
      "b99ad65d2b7649420e528180d27888be27c7a58f63adb35469780dab9225fd07";

    function sha256Hex(str) {
      // js-sha256 exposes a global `sha256` function
      if (typeof sha256 !== "function") {
        throw new Error("SHA-256 library not loaded.");
      }
      return sha256(str); // returns hex string
    }

    // Helper to parse HTML string and get text + image sources
    function parsePostHtml(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(html, "text/html");
      const text = doc.body.innerText || "";
      const imgs = Array.from(doc.querySelectorAll("img")).map(img =>
        img.getAttribute("src")
      );
      return { text, images: imgs };
    }

    function copyTextToClipboard(text) {
      // Prefer modern Clipboard API when available
      if (navigator.clipboard && navigator.clipboard.writeText) {
        return navigator.clipboard.writeText(text);
      }

      // Fallback: execCommand('copy') via a hidden textarea
      return new Promise((resolve, reject) => {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        textarea.setAttribute("readonly", "");
        textarea.style.position = "fixed";
        textarea.style.left = "-9999px";
        textarea.style.top = "0";

        document.body.appendChild(textarea);
        textarea.focus();
        textarea.select();

        try {
          const successful = document.execCommand("copy");
          document.body.removeChild(textarea);
          if (!successful) {
            reject(new Error("Fallback copy failed"));
          } else {
            resolve();
          }
        } catch (err) {
          document.body.removeChild(textarea);
          reject(err);
        }
      });
    }

    async function copyPostToClipboard(postHtml, setStatus) {
      const { text, images } = parsePostHtml(postHtml);

      const canWriteImages =
        navigator.clipboard &&
        navigator.clipboard.write &&
        window.ClipboardItem;

      // If we can't copy images, we’ll only count the text in total
      const total = 1 + (canWriteImages ? images.length : 0);
      let step = 0;

      try {
        // 1) Copy text (with fallback)
        await copyTextToClipboard(text);
        step++;
        setStatus(`Copied ${step}/${total} element - text`);

        // If browser can't handle image clipboard, stop here
        if (!canWriteImages) {
          if (images.length > 0) {
            setStatus(
              `Copied 1/1 element - text (your browser doesn't support programmatic image copy).`
            );
          } else {
            setStatus(`Copied 1/1 element - text`);
          }
          return;
        }

        // 2) Copy each image (only if supported)
        for (let i = 0; i < images.length; i++) {
          const src = images[i];
          if (!src) continue;

          const resp = await fetch(src);
          const blob = await resp.blob();

          const item = new ClipboardItem({
            [blob.type || "image/png"]: blob
          });
          await navigator.clipboard.write([item]);

          step++;
          setStatus(
            `Copied ${step}/${total} element - image ${i + 1}`
          );
        }

        if (images.length === 0) {
          setStatus(`Copied ${total}/${total} element - text`);
        } else {
          setStatus(`Done. Copied ${total}/${total} elements.`);
        }
      } catch (err) {
        console.error(err);
        setStatus("Copy failed: " + err.message);
      }
    }

    function App() {
      const [posts, setPosts] = useState([]);
      const [loading, setLoading] = useState(true);
      const [loadError, setLoadError] = useState(null);

      const [showSecretPanel, setShowSecretPanel] = useState(false);
      const [passphrase, setPassphrase] = useState("");
      const [secretStatus, setSecretStatus] = useState("");
      const [unlocked, setUnlocked] = useState(false);
      const [keyBuffer, setKeyBuffer] = useState("");

      // Load posts from ./posts/*.html
      useEffect(() => {
        async function loadAll() {
          try {
            const loaded = await Promise.all(
              POST_FILES.map(async (filename) => {
                const res = await fetch("./posts/" + filename);
                if (!res.ok) {
                  throw new Error(`Failed to load ${filename}: ${res.status}`);
                }
                const html = await res.text();
                return {
                  id: filename,
                  filename,
                  title: filename,
                  html,
                  copyStatus: "",
                  copying: false
                };
              })
            );
            setPosts(loaded);
          } catch (err) {
            console.error(err);
            setLoadError(err.message);
          } finally {
            setLoading(false);
          }
        }
        loadAll();
      }, []);

      // Detect secret key sequence ':::'
      useEffect(() => {
        function onKeyDown(e) {
          if (e.key === ":") {
            setKeyBuffer(prev => {
              const next = (prev + ":").slice(-3);
              if (next === ":::") {
                setShowSecretPanel(true);
                setSecretStatus("Secret panel unlocked. Enter passphrase.");
                return "";
              }
              return next;
            });
          } else {
            setKeyBuffer("");
          }
        }
        window.addEventListener("keydown", onKeyDown);
        return () => window.removeEventListener("keydown", onKeyDown);
      }, []);

      async function handleCheckPassphrase(e) {
        e.preventDefault();
        setSecretStatus("Checking passphrase...");
        try {
          const hash = await sha256Hex(passphrase);
          if (hash === SECRET_HASH) {
            setUnlocked(true);
            setSecretStatus("Passphrase valid. Hidden copy buttons enabled.");
          } else {
            setUnlocked(false);
            setSecretStatus("Invalid passphrase.");
          }
        } catch (err) {
          console.error(err);
          setSecretStatus("Error: " + err.message);
        }
      }

      function updatePostStatus(id, newState) {
        setPosts(prev =>
          prev.map(p =>
            p.id === id ? { ...p, ...newState } : p
          )
        );
      }

      async function handleCopyClick(post) {
        if (post.copying) return;
        updatePostStatus(post.id, { copying: true, copyStatus: "Starting copy..." });
        await copyPostToClipboard(post.html, (msg) =>
          updatePostStatus(post.id, { copyStatus: msg })
        );
        updatePostStatus(post.id, { copying: false });
      }

      return (
        <div className="app">
          <h1>DevOps Posts</h1>
          {/*
          <div className="hint">
            Press <code>:</code> three times (<code>:::</code>) anywhere to reveal a secret panel.
          </div>
          */}

          {showSecretPanel && (
            <div className="secret-panel">
              <span>Secret mode:</span>
              <form onSubmit={handleCheckPassphrase}>
                <input
                  type="password"
                  placeholder="Enter passphrase"
                  value={passphrase}
                  onChange={e => setPassphrase(e.target.value)}
                />
                <button type="submit">Check</button>
              </form>
              <span
                className={
                  "secret-status" +
                  (secretStatus.startsWith("Invalid") ? " error" : "")
                }
              >
                {secretStatus}
              </span>
            </div>
          )}

          {loading && (
            <div className="loading">Loading posts…</div>
          )}
          {loadError && (
            <div className="error-global error">
              Failed to load posts: {loadError}
            </div>
          )}

          <div className="posts-container">
            {posts.map(post => (
              <article key={post.id} className="post-card">
                <div className="post-title">{post.filename}</div>
                <div
                  className="post-content"
                  dangerouslySetInnerHTML={{ __html: post.html }}
                />
                <div className="post-footer">
                  <span>{post.copyStatus || " "}</span>
                  {unlocked && (
                    <button
                      className="copy-btn"
                      onClick={() => handleCopyClick(post)}
                      disabled={post.copying}
                    >
                      {post.copying ? "Copying…" : "Copy"}
                    </button>
                  )}
                </div>
              </article>
            ))}
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById("root"));
    root.render(<App />);
  </script>
</body>
</html>
